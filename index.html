<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>íšŒì¥ë‹˜ê³¼ì˜ ëŒ€í™”</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: #f2f2f2;
      text-align: center;
    }
    .character img {
      max-width: 90vw;
      max-height: 45vh;
      object-fit: contain;
      margin-top: 1rem;
    }
    .bubble {
      background: white;
      padding: 1rem 1.5rem;
      border-radius: 20px;
      border: 2px solid #888;
      margin: 1rem auto;
      width: 80vw;
      max-width: 320px;
      font-size: 1rem;
      box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
    }
    button, input[type="text"] {
      font-size: 1rem;
      padding: 0.8rem;
      margin: 0.5rem auto;
      width: 80%;
      max-width: 400px;
      display: block;
    }
  </style>
</head>
<body>
  <h1>Groq AI ëŒ€í™”í˜• ì±—ë´‡</h1>
  <div class="character">
    <img id="face" src="mouth_closed.png" alt="ìºë¦­í„° ì´ë¯¸ì§€">
  </div>
  <div class="bubble" id="bubble">ë¬´ì—‡ì´ë“  ì§ˆë¬¸í•´ë³´ì„¸ìš”!</div>
  <input type="text" id="textInput" placeholder="ì±„íŒ…ìœ¼ë¡œ ì§ˆë¬¸í•´ë³´ì„¸ìš”" />
  <button onclick="handleTextInput()">ğŸ’¬ ì§ˆë¬¸í•˜ê¸°</button>
  <button onclick="startListening()">ğŸ¤ ìŒì„±ìœ¼ë¡œ ì§ˆë¬¸í•˜ê¸°</button>

  <script>
    const bubble = document.getElementById("bubble");
    const face = document.getElementById("face");
    const textInput = document.getElementById("textInput");
    const closedMouth = "mouth_closed.png";
    const openMouth = "mouth_open.png";
    let speakingInterval = null;
    let preferredVoice = null;

    // ğŸ§  ëŒ€í™”í˜• ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ì €ì¥
    const conversationHistory = [];

    function animateMouth(open = true) {
      if (open) {
        let toggle = false;
        speakingInterval = setInterval(() => {
          face.src = toggle ? openMouth : closedMouth;
          toggle = !toggle;
        }, 250);
      } else {
        clearInterval(speakingInterval);
        face.src = closedMouth;
      }
    }

    function speak(text) {
      bubble.innerText = text;
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = "ko-KR";
      if (preferredVoice) utter.voice = preferredVoice;
      animateMouth(true);
      utter.onend = () => animateMouth(false);
      window.speechSynthesis.speak(utter);
    }

    async function getAIAnswer(prompt) {
      if (!prompt || prompt.trim().length === 0) {
        return "ì§ˆë¬¸ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.";
      }

      const userMessage = { role: "user", content: "ë‹¤ìŒ ì§ˆë¬¸ì— í•œêµ­ì–´ë¡œ ë‹µí•´ì¤˜: " + prompt.trim() };
      conversationHistory.push(userMessage);

      const bodyData = {
        model: "llama3-8b-8192",
        messages: conversationHistory,
        temperature: 0.7,
        top_p: 1,
        stream: false
      };

      console.log("ë³´ë‚´ëŠ” ìš”ì²­:", bodyData);

      try {
        const response = await fetch("https://api.groq.com/openai/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer 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"
          },
          body: JSON.stringify(bodyData)
        });

        const data = await response.json();

        if (!response.ok) {
          console.error("âŒ ì‘ë‹µ ì˜¤ë¥˜:", response.status, data);
          alert("Groq ì˜¤ë¥˜: " + (data?.error?.message || "ìƒì„¸ ë©”ì‹œì§€ ì—†ìŒ"));
          return `GPT ìš”ì²­ ì‹¤íŒ¨ (ìƒíƒœ ì½”ë“œ: ${response.status})`;
        }

        const reply = data.choices?.[0]?.message?.content?.trim() || "AI ì‘ë‹µ ìƒì„± ì‹¤íŒ¨";
        conversationHistory.push({ role: "assistant", content: reply }); // ì‘ë‹µ ì €ì¥
        return reply;

      } catch (err) {
        console.error("ğŸš¨ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜:", err);
        return "Groq API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”.";
      }
    }

    async function handleTextInput() {
      const input = textInput.value.trim();
      if (!input) {
        bubble.innerText = "ì§ˆë¬¸ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!";
        return;
      }
      bubble.innerText = "AIê°€ ìƒê° ì¤‘ì´ì—ìš”... ğŸ¤”";
      const answer = await getAIAnswer(input);
      speak(answer);
      textInput.value = "";
    }

    function startListening() {
      const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      recognition.lang = "ko-KR";
      recognition.interimResults = false;

      bubble.innerText = "ë“£ê³  ìˆì–´ìš”... ğŸ§";
      recognition.start();

      recognition.onresult = async function (event) {
        const transcript = event.results[0][0].transcript;
        const answer = await getAIAnswer(transcript);
        speak(answer);
      };

      recognition.onerror = () => {
        bubble.innerText = "ìŒì„± ì¸ì‹ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”.";
      };
    }

    // âŒ ìŠ¤í˜ì´ìŠ¤ ìŒì„±ì¸ì‹ ë¹„í™œì„±í™” (ì‚­ì œë¨)

    textInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        handleTextInput();
      }
    });

    window.speechSynthesis.onvoiceschanged = () => {
      const voices = window.speechSynthesis.getVoices();
      // ë‚¨ì„± ëª©ì†Œë¦¬ ìš°ì„  ê²€ìƒ‰
      const maleVoice = voices.find(v =>
        v.lang === "ko-KR" &&
        (v.name.includes("Google í•œêµ­ì˜ ë‚¨ì„±") || v.name.toLowerCase().includes("male"))
      );
      preferredVoice = maleVoice || voices.find(v => v.lang === "ko-KR");
    };
  </script>
</body>
</html>
